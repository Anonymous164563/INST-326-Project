DISCLAIMER: Use calculatorApp.py as the runnable file

By utilizing the following library 
"Mathplotlib(Enables for sin, cos, compatibility)
SymPy(Creates symbolic math schema)
Ttk(Creates the usable interface)"
The application will have only two functions, 24 in total. Furthermore, there will be three classes, called MathEngine and PlotManager and GraphingCalculatorApp. One to do the displaying of the interface(buttons, tabs, etc.). T
he other will do the calculations. We call the functions graph_Display and graph_Calculations, respectively. 
We have the function evaluate expression, and look into the expressions. 
Within the function called graph_Calculations, the algorithms for calculating the various graphs were implemented. 
Here, the library for calculating these graphs was the SymPy library. The keyword used here was sym. 
Wherever you see sym was where the library for SysSym and its various functions was implemented. 
The calc_value function examines the values entered in the box that stores the expression in x to determine whether it should be calculated or displayed in the graph. The first function, def _evaluate_expression_for_graph(self, expression),  accepts the variabels for the variable x when entering the equations, expr would comvert the uppercase chevron symbol into ** to be accepted by sympy. Without this, sympy will not work. The variable f, also know as function, will do the hard core caluclations. Accepting x, expr, and modules. Modules enables you to have access to all of numpy's available calculations. X_vals, creates the spacing for the graph. The y-vals variable f(x_vals) looks into scans the values entered for the x value and then computes a calculation.. Finally we will call the x and y values entered. The PlotManager class accepts the functions def __init__(self, plot_area, canvas), which accepts the parameters plot_area and canvas. We first used the variable self to append ther contents of plot_area and canvas. Setting plot_area and canvas to an empty container variable. We then created def draw_graph(self, x_vals, y_vals, expression), accepting x_vals, y_vals, and expression as acceptible parameters. We first wanted to enable something to first clear the plot when the app is refreshed or a new function was entered.  We then plotthe x values, y values set the co,lorsa and then the labels to then evaluate the expression. Then, we create the title for the app. Setting the x abnd the f(x) as the label for the y axis. We then create the legend for the app. To make it easy for user to analyze the app. We then render the grid and finally draw the graph. Next we define a class called GraphingCalculatorApp with the first function beign called  def __init__(self, root), which accepts the parameters self and root we intitialzie root, combining it with the container variable to store what would be the end result for our app. We set the title for our app to be Graphing Calculator, calling the background gradient in which we defined as ibiza_sunset(), after that we wanted to called the ecxpression entry box for the caluclator appending it to the root, the basis for emebdding all the content of our app. We do the same for the _create_area() and  create_buttons() functions. Next we intitiate the MathEngine() class by then combining it with self followed by dot math_engine. Now self contains all the information in the MathEngine(). We then do the same thing for the PlotManager() class, passing in the acceptible parameters of plot_area and plot_canvas respectfully. To draw the gradients we use the bind method to combine all the infromation in the redraw_gradient function and then  after it's done renedering, render the bottom half of the gradient. Later we create the sunset gradient function.  We create the dimensions for the frame of the gradient, we place the gradeint and draw the gradient dependent of the width and height parameters. We then wanted t nspecify a redraw_gradient function to redraw the gradient if the program was closed and reopened again. Wanting to render the gradient from bottom to the top. The we created a function to render the 3d surface images accepting the apramter sof x y and a optional parmater of d. In that function we also conver the acceptibel text inot a expression that Sympy can understand. Then, we create a function called  get_3d_expression, responsible for getting the 3d image of the expression entered. The create_xpression_entry  creates the entry boxes utilizing Tkinter. create_x_value_entry would create the place for you to enter all of your x values, the create_buttons function will then create the button layout for the user to etner their values. create_numeric_operator_buttons would connect back to the aforemetioned function and create the actual layour for the user to interact with. create_fucntion_buttons would create the clickable buttosn for the user to click and use. create_graph_area will render a blank graphing area for the user to view. on_button_click will then calculate the value of the expression when the = sign is entered. graph_calucations will graph the expressions entered. sin_3d function just graphs the basic sin(x) function. The values are hard coded inot the file. cos_3d is te same story. The _3d_Callback_render function evalues and checks if the ecxpressios entred are indeed a renderbale 3d image. If not, an error will be produced stating for the user toe nter a valid expression. The function heavily utilizes numpy as the acceptible library to enable for calculations. The function creates the spacing also for the graphs. The three_dim_animate will the render a hard coded image of a animated 3d rendering of a function

